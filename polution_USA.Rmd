---
title: "Pollution aux USA"
author: "Clément PEREON et Jules AVIGNON"
date: "2023-11-22"
output: html_document
---

```{r echo=FALSE}
library(tidyverse)
library(ggplot2)
library(fda)
library(reshape2)
library(wavethresh)
library(lubridate)
library(splines)
library(dplyr)
```

# Importation des données

```{r}
data_pollution <- read.csv("data_pollution.csv", sep=";")

data_pollution$Date.Local <- as.Date(data_pollution$Date.Local)

data_pollution <- data_pollution %>% group_by(City, Date.Local) %>% slice(1)
```

Ces données contiennent les taux dans l'air de quatre polluants mesurés journalièrement pour 30 villes aux États-Unis, entre 2000 et 2016.
Dans la suite, nous avons choisi d'étudier le NO2, car ce polluant est plus pertinent dans le contexte de la qualité de l'air, en particulier dans les zones urbaines. Les émissions de NO2 sont souvent liées aux activités de combustion, telles que le trafic automobile et les installations industrielles.

# Description et représentations informatives des données

## Statistiques descriptives

```{r}
summary(data_pollution$NO2.AQI)

ggplot(data_pollution, aes(x = NO2.AQI)) +
  geom_histogram(binwidth = 5, fill = "blue", color = "black") +
  labs(title = "Distribution de NO2.AQI", x = "NO2.AQI", y = "Fréquence")
```

## Tendance temporelle

```{r}
ggplot(data_pollution, aes(x = Date.Local, y = NO2.AQI, group = City, color = City)) +
  geom_line() +
  labs(title = "Tendance temporelle de NO2.AQI", x = "Date", y = "NO2.AQI")
```

Représentation peu lisible, nécéssité de lisser les donner et de faire du cas par cas.

Pour une meilleure visualisation, nous prenons les données de la ville de Phoenix car c'est la première ville du jeu de données.

```{r}
data_pho <- subset(data_pollution, City == "Phoenix")

ggplot(data_pho, aes(x = Date.Local, y = NO2.AQI)) +
  geom_line(color = "blue") +
  labs(title = "Tendance temporelle de NO2.AQI à Phoenix", x = "Date", y = "NO2.AQI")
```

## Identification des pics de pollution

```{r eval=FALSE}
# Identifier les jours avec des niveaux élevés de NO2.AQI
high_NO2_days <- data_pollution %>%
  filter(NO2.AQI > 100)  # Remplacez 'seuil' par votre valeur seuil

# Graphique des pics de pollution
ggplot(data_pollution, aes(x = Date.Local, y = NO2.AQI)) +
  geom_line() +
  geom_point(data = high_NO2_days, aes(x = Date.Local, y = NO2.AQI, color = "red")) +
  labs(title = "Identification des pics de pollution de NO2.AQI", x = "Date", y = "NO2.AQI")
```

Avec le temps, on observe de moins en moins de pics de pollution.

## Corrélations avec d'autres polluants

```{r}
# Matrice de corrélation
cor_matrix <- cor(data_pollution[, c("NO2.AQI", "O3.AQI", "SO2.AQI", "CO.AQI")])
print(cor_matrix)

# Graphique de dispersion
pairs(data_pollution[, c("NO2.AQI", "O3.AQI", "SO2.AQI", "CO.AQI")])
```

## Représentation de Phoenix pour chaque année

```{r}
smoothed_data$Year <- format(smoothed_data$Date.Local, "%Y")
smoothed_data_NY <- smoothed_data[which(smoothed_data$City=="Phoenix"),]

ggplot(smoothed_data_NY, aes(x = as.numeric(format(Date.Local, "%j")), y = smoothed_NO2, group = Year, color = Year)) +
  geom_line() +
  labs(title = "Évolution de NO2.AQI à Phoenix (2000-2016)",
       x = "Jour de l'année",
       y = "NO2.AQI") +
  theme_minimal()

```

# Lissage des données

## Fourier

On teste d'abord avec la ville de New York pour tenter d'obtenir le meilleur lissage de Fourier.

```{r}
data_phoenix <- filter(data_pollution, City == "Phoenix")

# Choisissez la variable que vous souhaitez lisser (par exemple, NO2.AQI)
variable_to_smooth <- data_phoenix$NO2.AQI

# Choisissez les valeurs de composants pour le lissage de Fourier
components_values <- c(2, 5, 10, 20)

# Initialiser un dataframe pour stocker les résultats lissés pour chaque valeur de composants
all_smoothed <- data.frame()

# Boucle sur les différentes valeurs de composants
for (n_components in components_values) {
  # Appliquer la transformation rapide de Fourier (FFT)
  fft_result <- fft(variable_to_smooth)
  
  # Zéro les composantes de fréquence au-delà des n_components premières
  fft_result[(n_components + 1):(length(fft_result) - n_components)] <- 0
  
  # Effectuer la transformation inverse de Fourier pour obtenir les données lissées
  smoothed <- Re(fft(fft_result, inverse = TRUE)) / length(fft_result)
  
  # Ajouter les données lissées à all_smoothed pour la valeur de composants actuelle
  smoothed_data <- data.frame(
    date = data_phoenix$Date.Local, 
    smoothed_variable = smoothed, 
    components = rep(n_components, length(smoothed))
  )
  
  all_smoothed <- rbind(all_smoothed, smoothed_data)
}

# Tracer les données originales et lissées pour différentes valeurs de composants
ggplot() +
  geom_line(data = all_smoothed, aes(x = date, y = smoothed_variable, color = as.factor(components))) +
  scale_color_manual(values = c("red", "green", "blue", "purple")) +
  labs(title = "Comparaison des Courbes Lissées pour Différentes Valeurs de Composants",
       x = "Date", y = "Variable Lissée") +
  theme_minimal() +
  theme(legend.position = "bottom")

```

Le meilleur composant semble être le 10 ??? à vérifier

On applique le lissage à toutes les villes.

```{r}

# Choisissez la variable que vous souhaitez lisser (par exemple, NO2.AQI)
variable_to_smooth <- data_pollution$NO2.AQI

# Choisissez le nombre de composants pour le lissage de Fourier
n_components <- 10

# Initialiser un dataframe pour stocker les résultats lissés pour chaque ville
all_smoothed <- data.frame()

# Boucle sur les différentes villes
for (city in unique(data_pollution$City)) {
  # Filtrer les données pour la ville actuelle
  one_city_data <- filter(data_pollution, City == city)
  
  # Appliquer la transformation rapide de Fourier (FFT)
  fft_result <- fft(one_city_data$NO2.AQI)
  
  # Zéro les composantes de fréquence au-delà des n_components premières
  fft_result[(n_components + 1):(length(fft_result) - n_components)] <- 0
  
  # Effectuer la transformation inverse de Fourier pour obtenir les données lissées
  smoothed <- Re(fft(fft_result, inverse = TRUE)) / length(fft_result)
  
  # Ajouter les données lissées à all_smoothed pour la ville actuelle
  smoothed_data <- data.frame(
    date = one_city_data$Date.Local, 
    smoothed_variable = smoothed, 
    city = rep(city, length(smoothed))
  )
  
  all_smoothed <- rbind(all_smoothed, smoothed_data)
}

# Tracer les données lissées pour toutes les villes
ggplot() +
  geom_line(data = all_smoothed, aes(x = date, y = smoothed_variable, color = city)) +
  labs(title = "Courbes Lissées pour NO2.AQI avec 10 Composants de Fourier",
       x = "Date", y = "Variable Lissée") +
  theme_minimal() +
  theme(legend.position = "bottom")
```





## Lissage avec Spline

```{r}
# Renommer votre jeu de données
all_stocks_data <- data_pollution

# Sélectionner la ville de Phoenix
one_stock_data <- filter(all_stocks_data, City == "Phoenix")

# Convertir la colonne "Date.Local" en classe Date
one_stock_data$Date.Local <- as.Date(one_stock_data$Date.Local)

# Créer une nouvelle colonne "date_num"
one_stock_data$date_num <- as.numeric(one_stock_data$Date.Local - min(one_stock_data$Date.Local))

# Initialiser un dataframe pour stocker les résultats lissés pour chaque valeur de noeud
all_smoothed <- data.frame()

# Boucle sur les différentes valeurs de noeuds
nbasis_values <- c(6, 10, 8, 12, 15)

for (nbasis in nbasis_values) {

  # Créer la base de spline pour la valeur de noeud actuelle
  splbasis <- bs(one_stock_data$date_num, df = nbasis, degree = 3, knots = NULL, intercept = FALSE)

  # Obtenir la matrice de base
  Phi <- predict(splbasis, newdata = list(x = one_stock_data$date_num))

  # Calculer les coefficients de la spline pénalisée
  chat <- solve(crossprod(Phi), crossprod(Phi, one_stock_data$NO2.AQI))

  # Ajouter les résultats lissés à all_smoothed
  all_smoothed <- rbind(all_smoothed, data.frame(
    date = one_stock_data$Date.Local,
    smoothed_NO2_AQI = Phi %*% chat,
    nbasis = nbasis
  ))
}

# Tracer les données originales et les courbes ajustées par spline avec ggplot2
gg <- ggplot() +
  geom_line(data = one_stock_data, aes(x = Date.Local, y = NO2.AQI), color = "blue", size = 1) +
  geom_line(data = all_smoothed, aes(x = date, y = smoothed_NO2_AQI, group = nbasis, color = as.factor(nbasis)), size = 1) +
  scale_color_discrete(name = "Nombre de Noeuds") +
  labs(title = "Régression Spline Pénalisée pour la Pollution NO2 à Phoenix avec Différents Noeuds",
       x = "Date",
       y = "NO2 AQI") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Afficher le graphique
print(gg)
```


## Lissage avec spline pénalisé

```{r}
# Définir un vecteur de valeurs de spar à tester
spar_values <- c(0.5, 0.7, 1.0, 1.5)

# Initialiser un dataframe pour stocker les résultats lissés pour chaque valeur de spar
all_smoothed <- data.frame()

# Boucle sur les différentes valeurs de spar
for (spar in spar_values) {
  # Ajuster une spline pénalisée avec la valeur de spar actuelle
  fit <- smooth.spline(one_stock_data$date_num, one_stock_data$NO2.AQI, spar = spar)
  
  # Ajouter les résultats lissés à all_smoothed
  smoothed <- data.frame(
    date = one_stock_data$Date.Local,
    smoothed_NO2_AQI = predict(fit, one_stock_data$date_num)$y,
    spar = as.factor(spar) # Convertir en facteur pour le coloriage par ggplot
  )
  
  all_smoothed <- rbind(all_smoothed, smoothed)
}

# Tracer toutes les courbes lissées avec différentes valeurs de spar sur un seul graphique
gg <- ggplot(all_smoothed, aes(x = date, y = smoothed_NO2_AQI, color = spar)) +
  geom_line() +
  labs(title = "Comparaison des Courbes Lissées pour Différentes Valeurs de Spar",
       x = "Date",
       y = "NO2 AQI Lissé") +
  theme_minimal() +
  theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

# Afficher le graphique
print(gg)
```



## Ondelettes 

```{r eval=FALSE, include=FALSE}
# Select one of the pollutants (e.g., NO2.AQI) for analysis
pollutant_data <- data_pollution$NO2.AQI

# Trouver la longueur la plus proche de puissance de deux
length_power_of_two <- 2^ceiling(log2(length(pollutant_data)))

# Remplir avec des valeurs manquantes ou tronquer pour atteindre la longueur
pollutant_data_adjusted <- c(pollutant_data, rep(NA, length_power_of_two - length(pollutant_data)))

# Effectuer une analyse en ondelettes
wavelet_result <- wd(pollutant_data_adjusted, filter.number = 4, family = "DaubExPhase")

# Restreindre le tracé à la longueur d'origine
plot(wavelet_result, main = "Wavelet Decomposition", xlim = c(1, length(pollutant_data)))


# Plot the wavelet decomposition
plot(wavelet_result)

# Extract wavelet coefficients
coefficients <- coef(wavelet_result)

# Plot the scaling function and wavelet functions
par(mfrow=c(1,2))
matplot(coefficients[, 1], type="l", main="Scaling function")
matplot(coefficients[, 2:ncol(coefficients)], type="l", main="Wavelet functions")

# Generate random functions using wavelet coefficients
n <- 30
nbbase <- ncol(coefficients)
random_functions <- matrix(0, ncol = n, nrow = nbbase)

for (i in 1:n) {
  random_functions[, i] <- apply(t(rnorm(nbbase, 0, 1) * t(coefficients)), 1, sum)
}

# Plot multiple random functions
matplot(random_functions, type="l", main="Random Functions")
```






# Analyse fonctionnelle

```{r}
data_long <- melt(data_pollution, id.vars=c("City", "Date.Local"), variable.name="Pollutant")
data_long$Date.Local <- as.Date(data_long$Date.Local)
data_long$Pollutant <- as.factor(data_long$Pollutant)

no2_data <- data_long[data_long$Pollutant == "NO2.AQI", ]
no2_fd <- smooth.spline(no2_data$Date.Local, no2_data$value, df = 10)

plot(no2_fd)


summary(no2_fd)

```

```{r}
no2_basis <- create.bspline.basis(rangeval = range(data_pollution$Date.Local), nbasis = 10)

no2_fd <- smooth.basis(argvals = data_pollution$Date.Local, y = data_pollution$NO2.AQI, fdParobj = no2_basis)

plot(no2_fd, main = "Analyse de données fonctionnelles de NO2.AQI")
```
La courbe obtenue à partir de l'analyse fonctionnelle peut montrer la tendance générale de la pollution de NO2.AQI au fil des années. On observe qu'il y a une diminution dans les niveaux de pollution.

```{r}
data_pollution <- data_pollution %>% group_by(City, Date.Local) %>% slice(1)

# Extraire le mois et l'année de la colonne Date.Local
data_pollution$Day <- format(data_pollution$Date.Local, "%b%d")
data_pollution$Year <- format(data_pollution$Date.Local, "%Y")

# Sélectionner uniquement les colonnes nécessaires
data_subset <- data_pollution[, c("City", "Day", "Year", "NO2.AQI")]

# Créer le nouveau data.frame avec les valeurs de NO2.AQI
new_df <- data_subset %>%
  pivot_wider(names_from = City, values_from = NO2.AQI)

data_2016 <- new_df[which(new_df$Year == "2016"),]
data_2016 <- column_to_rownames(data_2016, var = "Day")
data_2016 <- data_2016[, -c(1:2)]

#conversion des variables de data_2016 en numérique
data_2016 <- data_2016 %>% mutate_all(as.numeric)
data_2016 <- as.matrix(data_2016)
```


```{r}
splbasis = create.bspline.basis(c(1,152),norder=4,breaks=seq(1,152,30))
gcv = 1:21
for (i in 1:21){
  lambda = exp(i-10)
  fdparTemp = fdPar(splbasis,Lfdobj = 2,lambda=lambda)
  smoothdata = smooth.basis(1:152,data_2016,fdParobj = fdparTemp)
  gcv[i] = mean(smoothdata$gcv)
}
plot(gcv)
which.min(gcv)
```



